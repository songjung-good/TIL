## 코드리뷰 받을 때
- 코드!=나
- 나에 대한 평가가 아니라 그저 코드에 대한 리뷰
- 리뷰해주는건 당연한 것은 아니다!
- 리뷰어에 대한 감사

## 코드리뷰
1. 빠르게 리뷰하기
    
    - P1 : 이번에 반드시 반영되어야 하는 중대한 코드 수정 의견(Request Changes)
    
       - 버그 가능성이 있거나 잘못된 구현인 경우, 만약 반영되지 않는다면 이에 대한 반대 의견도 낼 수 있어야 한다.
    
    - P2 : 적극적으로 이야기했으면 하는 의견(Request Changes)
    
       - 잠재적인 이슈나 확장성을 고려해야 하는 경우. 토론하며 의견 조율할 수 있다.
    
    - P3 : 가능하다면 반영해주었으면 하는 의견(Request Changes)
    
       -  지금 구현보다 더 나은 방향이 있는 경우. 이번 반영이 얼벼다면 다음 작업에서도 고려해볼 수 있도록 한다.
    
    - P4 : 다음에 반영해도 되는 의견 (Approve)
    
       - 반영이 되지 않거나 반대 의견을 적극적으로 할 필요 없다.
    
    - P5 : 사소한 의견(Approve)
    
       - 무시해도 됨. 혹은 관련 나누고 싶은 점 나눌 수 있다.
    
    
2. nit 줄이기
    - 사소하고 작은 문제로 주로 스타일 가이드 준수, 가독성 개선 등을 의미
    - 전체적으로는 중요하지 않지만 품질 햐상에 도움이 될 수 있는 부분에서 사용
3. 변경 사이즈 줄이기

## 크롬 익스텐션
- WorkerB for Pull requests

--------------------------------

# Agaile 개발론

1. 애자일개발이란?
  
2. 등장배경
  
3. 장단점
  
4. 애자일 프레임워크
  

## 정의

- 사전적 의미 : 신속한, 날렵한, 기민한
  
- sw 방법론 : 짧은 주기의 개발 단위를 반복하며 프로젝트를 완성
  
- how? : 스프린트(sprint)단위로 디자인-> 개발 -> 테스트 반복
  

## 특징

- 고객과 개발자의 지속적인 소통으로 변화하는 요구 사항 신속하게 반영 가능
  
- 개인 보다는 팀의 목적 우선시, 고객의 의견을 가장 높은 가치로
  
- 팀원들의 주기적인 회의 및 시현을 통해 잠재적인 보그 수정, 미흡한 기능 추가
  
- 고객으로부터 즉각적인 피드백을 통한 수정, 보완 가능
  
- 팀원들과의 주도적이며 자발적인 개발 문화로 프로그램의 전체적 품질 향상
  

=> 게임, 배달 앱, 대부분의 앱 프로그램 등

- 서비스의 요구사항 빈번히 수정되고 반복적인 업데이트 필요한 프로젝트

## 폭포수(워터풀) 개발론

- 가장 오래된 sw 개발론
  
  - 각 작업이 마치 폭포수가 내려가듯이 작업 절차 진행
    
  - 한 단계가 마무리되기 전 다음 단계로 진행 안됨
    
  - 속도 느리고 유연하지 못함
    
  - 요구 사항이 바뀌거나 수정하려면 다시 맨 처음부터 수정해야 하는 불편함
    

=> B2B(Business to Business)

- 은행권 업무, POS 프로그램, 키오스크
  
- 프로세스가 비교적 정확, 요구사항 변동 적음
  

## 장단점

- 장점
  
  - 프로젝트 계획에 걸리는 시간 최소화
    
  - 반복적인 테스트로 잠정적인 버그 쉽고 빠르게 개선 가능
    
  - 계획 변경, 기능 추가에 유연
    
  - 고객의 요구 사항에 대한 즉각적인 피드백에 유연, 프로토타입 모델 빠르게 출시 가능
    
  - 비교적 빠르게 제품 출시 가능
    
- 단점
  
  - 반복적인 유지 보수 작업 많음
    
  - 요구 사항 및 계획이 크게 변경될 경우 모델 자체가 무너질 수 있음
    
  - 공통 작업의 리소스 투입이 많음
    
  - 개발속도는 빠르나 번아웃 현상 쉽게 올 수 있음
    
  - 확정되지 않은 계획으로 인해 개발 진행에 대한 정확한 이해 부족 발생 가능
    

## 애자일 프레임 워크

- MVP(Minimum Viable Product) : 최소 기능 제품
  
  - 고객이 우너하는 제품의 최소한을 정의
    
    - 최소 비용, 핵심 기능 만을 담은 제품
      
    - 시간과 비용 절감 측면에서 효율적
      
    - 사업 리스크 최소화
      
- 스프린트(Sprint)
  
  - 팀의 일정량의 작업을 완료하기 위해 정해진 짧은 기간
    
  - 스프린트 계획 회의 - 스프린트 기간 동안 해야할 일들을 정리하고 달성하기 위한 방법 회의
    
- 스크럼(Scrum)
  
  - 정해진 스프린트 내에 실제 행해져야 하는 개발 업부
    
  - 제품 백로그 작성 : 고객, 프로젝트 이해관계자 의견 취합, 업무 우선 순위 매기는 작업
    
  - 스프린트 백로그 작성 : 스프린트 내에 각 팀원들이 해야할 업무의 리스트 만드는 작업
    
  - 데일리 스크럼 : 매일 진행한 업무를 보고하고 공유
    
  - 개발 및 테스트 : 실제 맡은 영역 개발, 테스트
    
  - 스프린트 리뷰 및 회고 : 장 단점 분석, 더 나은 방향으로 개선
    
- 테스트 주도적 개발
  
  - 실제 필요한 기능만 만들고 그 기능이 제대로 동작하는지 코드 기반 테스트
    
  - 잘 동작 => 코드 리팩토링 및 모듈화
    
- 데브옵스
  
  - 개발 + 운영
    
  - 새로운 소프트웨어 기능 개선, 버그 수정시 바로 배포함 => 빠른 피드백 가능
    
  - 지속적 통합 및 연속 배포(CI/CD) 구축


------------------------------

## TIP

- 너무 새로운 것에 집착하지 말자. 기존 프로젝트를 부분적으로 고쳐 개선하는 것도 좋은 프로젝트!
- 회의 시에는 항상 회의 시간을 정해두고 하자. 무조건 진행하는 회의는 에너지 낭비
- 기술에 너무 매몰되지 말자.
- 공통 모든 명세서를 훑어보고 다양한 기술 중 우리팀에 맞는 기술 선택
- ! 프로젝트의 메인 기능을 명확하게 도출할 것.

## 프로젝트 당위성

- 행복 회로에 갇혀 다른 유저들이 사이트를 왜 써야 하는지에 대해 고민하지 않음
  
- 최초 유저를 끌어들이는 방법 또는 다양한 유저가 관심있어할 기능에 대한 고민 필요
  
- 포괄적인 기능을 가지고 있는 것들은 개발하기 어려움 (블로그)
  
- 명확한 주제가 있는 프로젝트를 하는 것이 규모와 일정을 맞추기 쉬움
  

## 세부 기획

- 메인 아이디어, 시스템화 되려면 필요한 기능에 대해 고민
  
- 시스템 프로세스에 전체적으로 필요한 부분(쇼핑몰 : 조회 > 장바구니 > 결제 > 배송조회)
  
- 대부분 시스템에 들어가는 공통영역(회원가입, 유저관리, 게시판, 관리자 페이지)
  
- 아이디어 -> 세부기획을 보고 누구나 이해할 수 있어야 함
  
- 작성된 내용을 보고 질문이 오지 않게 작성(질의응답 => 문서 업데이트)
  
- 할 수 있는 한 자세하기~
  
- 기능명세/화면설계/DB설계에서 작성된 내용이 동일한지가 가장 중요


-----------------------------

# 아키텍처의 정의와 설계 방법

- 아키텍처의 필요성에 대한 인지
  
- 목적에 맞는 아키텍처 문서작성 방법의 이해
  

## 정의

- 아키텍처 : 건물이나 다른 구조물을 계획하고 건설하는 **과정과 그 결과물**
  
- SW아키텍처
  
  - 소프트웨어 구성요소드 사이에서 유기적 관계를 표현하고
    
  - 소프트웨어의 설계와 업그레이드를 통제하는 **지침과 원칙**이다.
    

## 어떻게 사용되는가?

- 초기 설계 과정의 결정 사항
  
  - 구현에 대한 제약사항 검토 및 시스템에 대한 구조 결정
    
- 커뮤니케이션의 기준점
  
  - 서비스나 시스템의 이해 당사자들 간의 공통분모
    
- 재사용 가능한 레퍼런스
  
  - 아키텍처를 결정짓게 한, 유사한 요구사항 및 설계 경험의 재사용
    

> 구현 방법에 대한 고도화 전략 수립 및 검토
> 
> Sequence 등 상세 구현 방법 결정 및 도식화의 근거자료
> 
> 팀내 의사결정 내용 Synchronized
> 
> 레퍼런스 축척

## 아키텍처 설계

- 학사관리시스템
  
  > 결정요인 도출
  > 
  > - 이해관계자 선별 : 시스템과 연관되는 사람이나, 다른 시스템   
  >   
  >   - 학생, 교수, 교직원, 외부시스템(인사관리, 학사관리 시스템)
  > - 기능요구사항
  >   
  >   - 학사 관리 기능, 수업 관리 기능, 수강 관리 기능, 사용자 관리 기능
  > - 비기능요구사항
  >   
  >   - 강의 신청 기간에 원활한 진행, 언제어디서나 접근 가능, 모바일 접속 가능, 권한을 통한 정보보안, 데이터 손실 방지
  
- 품질속성시나리오 & 비기능요구사항
  
  - 스파이크 성 트래픽에 대한 처리, public 환경, 하이브리드 앱
    

## 정리

- 아키텍처 그리기 순서
  
  - 비기능요구사항 도출 > 품질속성 시나리오 작성 > 아키텍처 패턴 결정 > 아키텍처 도식화
    
  
  1. 품질속성을 정확히 정의
    
  2. 품질속성 별로 전략 도출
    
  3. 도출된 전략을 잘 보여줄 수 있게 도식화
    
  4. 아키텍처 검증(평가)


------------------

### 깃의 사용 이유

*   소스코드 관리
*   협업 개발

### 깃 기본 설정

*   깃 커밋 정보
    *   소스코드 변경 내용과 함께 작성자의 이름과 이메일도 포함
    *   문제 상황이나 코드 리뷰시 중요한 정보
    *   특히 여러 명의 개발자가 동시에 작업해야 하는 상황에서는 더욱 중요
*   정확한 이름과 이메일 사용gt 중요

### git config

*   GIT 사용 환경 설정 도구(명령어)
    *   GIT을 사용하기 위해서는 git config 명령을 통해 이름과 이메일 주소 설정 필수
    *   커밋 정보에 포함되어 누가 커밋을 했는지 알 수 있도록 해 줌

### GIT 커밋 메세지 컨벤션

*   GIT 커밋 메시지
    
    *   다른 개발자의 작업 내역이나 변경사항을 파악하는데 이용
    *   변경 이력 추적 및 문제 해결에 도움
*   Conventional Commits
    
    *   가벼운 컨벤션으로 명확한 커밋 히스토리를 생성하기 위한 간단한 규칙 제공
    *   커밋 메시지에 신규 기능 추가, 문제 수정, 커다란 변화가 있음을 기술함
    
    [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/)
    
*   커밋 메시지 구조 (제목, 본문, 꼬리말)
    
        <type>[optional scope]: <description>
        
        [optional body]
        
        [optional footer(s)]
        
    
    *   타입
        *   fix와 feat 이외의 타입 허용
        *   앵귤러 컨벤션 : build, chore, ci, docs, style, refactor, perf, test 등
    *   설명
        *   작업한 내용을 최대한 함축하여 대략 50자 이내로 작성
    *   본문 (선택사항)
        *   기본적으로는 선택사항이지만 **가급적 작성**
        *   자유로운 형식으로 필요시 여러 단락으로도 작성 가능
        *   무엇을 변경했는지 보다는 **왜 수정 했는지**를 설명
    *   꼬리말
        *   필요시 작성
        *   연관되어 있는 JIRA 이슈 번호 등을 작성
*   커밋 메시지를 통해 코드 리뷰어에게 정보 제공
    
    *   Gerrit을 통한 코드 리뷰시 커밋 단위로 코드 리뷰
    *   빠른 리뷰를 위해서는 리뷰어에게 정보 제공 필요
    *   커밋 메시지 본문을 통해 정보 제공

### GIT 브랜치 전략

*   Git 브랜치
    
    *   독립적인 개발 공간 제공
    *   쉽고 빠르게 브랜치를 생성하고 이동 가능
    *   아이디어를 쉽게 시험해 볼 수 있음
*   브랜치 전략
    
    *   쉽고 편리한 브랜치, 계획없이 만들다 보면 남용될 수 있음
    *   브랜치를 효율적으로 사용하는 방법에 대한 다양한 브랜치 전략 제시
    *   가장 대표적인 브랜치 전략은 gitflow
    *   최근에는 배포 주기가 빨라지면서 다른 전략도 모색함(Github flow, Gtlab flow 등) → Gitflow 보다 단순한 형태로 배포가 매우 잦은 환경에 적합함.
    
*   Gitflow 전략
    
    *   master, develop, feature, release, hotfix 5가지 브랜치로 관리
    *   브랜치 마다 목적이 명확
    *   브랜치별 생명 주기에 따른 처리 주의

### Git 히스토리 중요성

*   Git History
    *   Git은 SW 변경 사항을 커밋 단위로 기록하기 때문에 커밋 이력의 모음이 있다
    *   Git 그래프나 로그로 확인한다.
*   Git 히스토리가 중요한 이유
    *   레거시 코드 유지 보수에 중요
    *   버그 발생 시점 파악 및 문제 해결 실마리 제공
*   버그 발생 시점 파악 및 문제 해결 실마리 제공
    *   과거 커밋 시점으로 돌아가서 동작 확인
    *   git checkout 명령어 이용

### 유용한 기능 - git stash

*   갑자기 끼어드는 작업
    
    *   A 기능 작업 중인데, 갑자기 B 기능 작업 해달라고 한다면
    *   새 작업 위해 새로운 브랜치를 생성하거나 기존 작업 중인 브랜치로 이동 필요
    *   생각보다 자주 발생
*   브랜치 이동 안되는 상황
    
    *   수정중인 파일이 있을 경우 브랜치 이동 불가
    *   커밋 하거나 수정 전 상태로 리셋 필요
*   git stash
    
    *   현재 작업중인 내용을 모두 stash 공간에 차곡차곡 쌓아 줌
    
        $ git stash save # 현재 작업 상태 백업
        ---
        새로운 작업 진행
        ---
        $ git stash pop # 이전 작업 상태 복구


-------------------------

Git 이해와 활용
----------

**Git 커밋 정보**
*   소스 코드 변경 내용과 함께 작성자의 이름과 이메일도 포함
*   문제 상황이나 코드 리뷰시 중요한 정보

**Git 사용 환경 설정 도구(명령어)**
*   git config —global [user.name](http://user.name) “(본인 이름)”
*   git config —global [user.email](http://user.email) “(싸피에서 등록된 이메일)”

**Git 커밋 메시지**
*   다른 개발자의 작업 내역이나 변경사항을 파악하는데 이용
*   변경 이력 추적 및 문제 해결에 도움

**Conventional Commits**
*   가벼운 컨벤션으로 명확한 커밋 히스토리를 생성하기 위한 간단한 규칙 제공
*   커밋 메시지에 신규 기능 추가, 문제 수정, 커다란 변화가 있음을 기술함
*   커밋 메시지 구조 - 제목, 본문, 꼬리말
    *   본문 작성 추천!! (코딩 스타일이나 간단한 수정은 예외)

**Git 브랜치**
*   독립적인 개발 공간 제공
*   쉽고 빠르게 브랜치를 생성하고 이동 가능
*   아이디어를 쉽게 시험해 볼 수 있음

**브랜치 전략**
*   쉽고 편리한 브랜치, 계획없이 만들다 보면 남용될 수 있음
*   가장 대표적인 브랜치 전략은 gitflow
    *   master, develop, feature, release, hotifx로 관리

**Git 히스토리**
*   레거시 코드 유지 보수에 중요
*   버그 발생 시점 파악 및 문제 해결 실마리 제공
    *   git checkout {커밋 번호}

**유용한 기능 - git stash**
*   수정중인 파일이 있어서 브랜치 이동이 불가능할 경우 사용
*   현재 작업중인 내용을 모두 stash 공간에 쌓아줌
